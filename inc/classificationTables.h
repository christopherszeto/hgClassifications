/* classificationTables.h was originally generated by the autoSql program, which also 
 * generated classificationTables.c and classificationTables.sql.  This header links the database and
 * the RAM representation of objects. */

#ifndef CLASSIFICATIONTABLES_H
#define CLASSIFICATIONTABLES_H

#include "jksql.h"
#define JOBS_NUM_COLS 13

struct jobs
/* All sample predictions and their accuracies */
    {
    struct jobs *next;  /* Next in singly linked list. */
    unsigned id;	/* Prediction Id (auto_increment) */
    unsigned datasets_id;	/* Datasets Id */
    unsigned tasks_id;	/* Task id */
    unsigned classifiers_id;	/* Classifiers Id */
    unsigned featureSelections_id;	/* FeatureSelections Id */
    unsigned transformations_id;	/* Trasnformations Id */
    unsigned subgroups_id;	/* Subgroups Id */
    float avgTestingAccuracy;	/* Average accuracy in tests */
    float avgTestingAccuracyGain;	/* Gain of average testing accuracy over majority classifier */
    char *accuracyType;	/* Accuracy Type (e.g. k-fold) */
    char *features;	/* csv of features used */
    char *weights;	/* csv of weights of features used */
    char *modelPath;	/* Path on disk to the model generated from this job */
    };

void jobsStaticLoad(char **row, struct jobs *ret);
/* Load a row from jobs table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct jobs *jobsLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all jobs from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with jobsFreeList(). */

void jobsSaveToDb(struct sqlConnection *conn, struct jobs *el, char *tableName, int updateSize);
/* Save jobs as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use jobsSaveToDbEscaped() */

void jobsSaveToDbEscaped(struct sqlConnection *conn, struct jobs *el, char *tableName, int updateSize);
/* Save jobs as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than jobsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct jobs *jobsLoad(char **row);
/* Load a jobs from row fetched with select * from jobs
 * from database.  Dispose of this with jobsFree(). */

struct jobs *jobsLoadAll(char *fileName);
/* Load all jobs from whitespace-separated file.
 * Dispose of this with jobsFreeList(). */

struct jobs *jobsLoadAllByChar(char *fileName, char chopper);
/* Load all jobs from chopper separated file.
 * Dispose of this with jobsFreeList(). */

#define jobsLoadAllByTab(a) jobsLoadAllByChar(a, '\t');
/* Load all jobs from tab separated file.
 * Dispose of this with jobsFreeList(). */

struct jobs *jobsCommaIn(char **pS, struct jobs *ret);
/* Create a jobs out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new jobs */

void jobsFree(struct jobs **pEl);
/* Free a single dynamically allocated jobs such as created
 * with jobsLoad(). */

void jobsFreeList(struct jobs **pList);
/* Free a list of dynamically allocated jobs's */

void jobsOutput(struct jobs *el, FILE *f, char sep, char lastSep);
/* Print out jobs.  Separate fields with sep. Follow last field with lastSep. */

#define jobsTabOut(el,f) jobsOutput(el,f,'\t','\n');
/* Print out jobs as a line in a tab-separated file. */

#define jobsCommaOut(el,f) jobsOutput(el,f,',',',');
/* Print out jobs as a comma separated list including final comma. */

void jobsJsonOutput(struct jobs *el, FILE *f);
/* Print out jobs in JSON format. */

#define TASKS_NUM_COLS 2

struct tasks
/* All prediction tasks */
    {
    struct tasks *next;  /* Next in singly linked list. */
    unsigned id;	/* Prediction task Id (auto_increment) */
    char *name;	/* Prediction task name */
    };

void tasksStaticLoad(char **row, struct tasks *ret);
/* Load a row from tasks table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct tasks *tasksLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all tasks from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with tasksFreeList(). */

void tasksSaveToDb(struct sqlConnection *conn, struct tasks *el, char *tableName, int updateSize);
/* Save tasks as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use tasksSaveToDbEscaped() */

void tasksSaveToDbEscaped(struct sqlConnection *conn, struct tasks *el, char *tableName, int updateSize);
/* Save tasks as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than tasksSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct tasks *tasksLoad(char **row);
/* Load a tasks from row fetched with select * from tasks
 * from database.  Dispose of this with tasksFree(). */

struct tasks *tasksLoadAll(char *fileName);
/* Load all tasks from whitespace-separated file.
 * Dispose of this with tasksFreeList(). */

struct tasks *tasksLoadAllByChar(char *fileName, char chopper);
/* Load all tasks from chopper separated file.
 * Dispose of this with tasksFreeList(). */

#define tasksLoadAllByTab(a) tasksLoadAllByChar(a, '\t');
/* Load all tasks from tab separated file.
 * Dispose of this with tasksFreeList(). */

struct tasks *tasksCommaIn(char **pS, struct tasks *ret);
/* Create a tasks out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new tasks */

void tasksFree(struct tasks **pEl);
/* Free a single dynamically allocated tasks such as created
 * with tasksLoad(). */

void tasksFreeList(struct tasks **pList);
/* Free a list of dynamically allocated tasks's */

void tasksOutput(struct tasks *el, FILE *f, char sep, char lastSep);
/* Print out tasks.  Separate fields with sep. Follow last field with lastSep. */

#define tasksTabOut(el,f) tasksOutput(el,f,'\t','\n');
/* Print out tasks as a line in a tab-separated file. */

#define tasksCommaOut(el,f) tasksOutput(el,f,',',',');
/* Print out tasks as a comma separated list including final comma. */

void tasksJsonOutput(struct tasks *el, FILE *f);
/* Print out tasks in JSON format. */

#define CLASSIFIERS_NUM_COLS 3

struct classifiers
/* All classifiers and their parameters */
    {
    struct classifiers *next;  /* Next in singly linked list. */
    unsigned id;	/* Classifier Id (auto_increment) */
    char *name;	/* Classifier method */
    char *parameters;	/* Classifier parameters */
    };

void classifiersStaticLoad(char **row, struct classifiers *ret);
/* Load a row from classifiers table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct classifiers *classifiersLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all classifiers from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with classifiersFreeList(). */

void classifiersSaveToDb(struct sqlConnection *conn, struct classifiers *el, char *tableName, int updateSize);
/* Save classifiers as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use classifiersSaveToDbEscaped() */

void classifiersSaveToDbEscaped(struct sqlConnection *conn, struct classifiers *el, char *tableName, int updateSize);
/* Save classifiers as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than classifiersSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct classifiers *classifiersLoad(char **row);
/* Load a classifiers from row fetched with select * from classifiers
 * from database.  Dispose of this with classifiersFree(). */

struct classifiers *classifiersLoadAll(char *fileName);
/* Load all classifiers from whitespace-separated file.
 * Dispose of this with classifiersFreeList(). */

struct classifiers *classifiersLoadAllByChar(char *fileName, char chopper);
/* Load all classifiers from chopper separated file.
 * Dispose of this with classifiersFreeList(). */

#define classifiersLoadAllByTab(a) classifiersLoadAllByChar(a, '\t');
/* Load all classifiers from tab separated file.
 * Dispose of this with classifiersFreeList(). */

struct classifiers *classifiersCommaIn(char **pS, struct classifiers *ret);
/* Create a classifiers out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new classifiers */

void classifiersFree(struct classifiers **pEl);
/* Free a single dynamically allocated classifiers such as created
 * with classifiersLoad(). */

void classifiersFreeList(struct classifiers **pList);
/* Free a list of dynamically allocated classifiers's */

void classifiersOutput(struct classifiers *el, FILE *f, char sep, char lastSep);
/* Print out classifiers.  Separate fields with sep. Follow last field with lastSep. */

#define classifiersTabOut(el,f) classifiersOutput(el,f,'\t','\n');
/* Print out classifiers as a line in a tab-separated file. */

#define classifiersCommaOut(el,f) classifiersOutput(el,f,',',',');
/* Print out classifiers as a comma separated list including final comma. */

void classifiersJsonOutput(struct classifiers *el, FILE *f);
/* Print out classifiers in JSON format. */

#define CLASSIFIERRESULTS_NUM_COLS 7

struct classifierResults
/* All classifier results */
    {
    struct classifierResults *next;  /* Next in singly linked list. */
    unsigned id;	/* Classifier Results Id */
    unsigned tasks_id;	/* Task Id */
    unsigned jobs_id;	/* Job Id */
    unsigned sample_id;	/* Sample */
    float trainingAccuracy;	/* Training accuracy */
    float testingAccuracy;	/* Testing accuracy */
    float predictionScore;	/* Raw prediction score, intended for binary classes use */
    };

void classifierResultsStaticLoad(char **row, struct classifierResults *ret);
/* Load a row from classifierResults table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct classifierResults *classifierResultsLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all classifierResults from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with classifierResultsFreeList(). */

void classifierResultsSaveToDb(struct sqlConnection *conn, struct classifierResults *el, char *tableName, int updateSize);
/* Save classifierResults as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use classifierResultsSaveToDbEscaped() */

void classifierResultsSaveToDbEscaped(struct sqlConnection *conn, struct classifierResults *el, char *tableName, int updateSize);
/* Save classifierResults as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than classifierResultsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct classifierResults *classifierResultsLoad(char **row);
/* Load a classifierResults from row fetched with select * from classifierResults
 * from database.  Dispose of this with classifierResultsFree(). */

struct classifierResults *classifierResultsLoadAll(char *fileName);
/* Load all classifierResults from whitespace-separated file.
 * Dispose of this with classifierResultsFreeList(). */

struct classifierResults *classifierResultsLoadAllByChar(char *fileName, char chopper);
/* Load all classifierResults from chopper separated file.
 * Dispose of this with classifierResultsFreeList(). */

#define classifierResultsLoadAllByTab(a) classifierResultsLoadAllByChar(a, '\t');
/* Load all classifierResults from tab separated file.
 * Dispose of this with classifierResultsFreeList(). */

struct classifierResults *classifierResultsCommaIn(char **pS, struct classifierResults *ret);
/* Create a classifierResults out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new classifierResults */

void classifierResultsFree(struct classifierResults **pEl);
/* Free a single dynamically allocated classifierResults such as created
 * with classifierResultsLoad(). */

void classifierResultsFreeList(struct classifierResults **pList);
/* Free a list of dynamically allocated classifierResults's */

void classifierResultsOutput(struct classifierResults *el, FILE *f, char sep, char lastSep);
/* Print out classifierResults.  Separate fields with sep. Follow last field with lastSep. */

#define classifierResultsTabOut(el,f) classifierResultsOutput(el,f,'\t','\n');
/* Print out classifierResults as a line in a tab-separated file. */

#define classifierResultsCommaOut(el,f) classifierResultsOutput(el,f,',',',');
/* Print out classifierResults as a comma separated list including final comma. */

void classifierResultsJsonOutput(struct classifierResults *el, FILE *f);
/* Print out classifierResults in JSON format. */

#define SUBGROUPS_NUM_COLS 4

struct subgroups
/* Names and parameters for subgroups */
    {
    struct subgroups *next;  /* Next in singly linked list. */
    unsigned id;	/* Subgroups Description Id (auto_increment) */
    char *name;	/* Subgrouping method */
    char *parameters;	/* Subgrouping parameters */
    unsigned datasets_id;	/* Dataset this subgrouping came from */
    };

void subgroupsStaticLoad(char **row, struct subgroups *ret);
/* Load a row from subgroups table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct subgroups *subgroupsLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all subgroups from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with subgroupsFreeList(). */

void subgroupsSaveToDb(struct sqlConnection *conn, struct subgroups *el, char *tableName, int updateSize);
/* Save subgroups as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use subgroupsSaveToDbEscaped() */

void subgroupsSaveToDbEscaped(struct sqlConnection *conn, struct subgroups *el, char *tableName, int updateSize);
/* Save subgroups as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than subgroupsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct subgroups *subgroupsLoad(char **row);
/* Load a subgroups from row fetched with select * from subgroups
 * from database.  Dispose of this with subgroupsFree(). */

struct subgroups *subgroupsLoadAll(char *fileName);
/* Load all subgroups from whitespace-separated file.
 * Dispose of this with subgroupsFreeList(). */

struct subgroups *subgroupsLoadAllByChar(char *fileName, char chopper);
/* Load all subgroups from chopper separated file.
 * Dispose of this with subgroupsFreeList(). */

#define subgroupsLoadAllByTab(a) subgroupsLoadAllByChar(a, '\t');
/* Load all subgroups from tab separated file.
 * Dispose of this with subgroupsFreeList(). */

struct subgroups *subgroupsCommaIn(char **pS, struct subgroups *ret);
/* Create a subgroups out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new subgroups */

void subgroupsFree(struct subgroups **pEl);
/* Free a single dynamically allocated subgroups such as created
 * with subgroupsLoad(). */

void subgroupsFreeList(struct subgroups **pList);
/* Free a list of dynamically allocated subgroups's */

void subgroupsOutput(struct subgroups *el, FILE *f, char sep, char lastSep);
/* Print out subgroups.  Separate fields with sep. Follow last field with lastSep. */

#define subgroupsTabOut(el,f) subgroupsOutput(el,f,'\t','\n');
/* Print out subgroups as a line in a tab-separated file. */

#define subgroupsCommaOut(el,f) subgroupsOutput(el,f,',',',');
/* Print out subgroups as a comma separated list including final comma. */

void subgroupsJsonOutput(struct subgroups *el, FILE *f);
/* Print out subgroups in JSON format. */

#define SAMPLESINSUBGROUPS_NUM_COLS 4

struct samplesInSubgroups
/* Sample subgroups used in classifications */
    {
    struct samplesInSubgroups *next;  /* Next in singly linked list. */
    unsigned id;	/* SamplesInSubgroups id (auto_increment) */
    unsigned subgroups_id;	/* Subgroups Id (corrosponds to subgroups Ids) */
    unsigned subgroup;	/* Subgroup assignment */
    unsigned sample_id;	/* Sample Id */
    };

void samplesInSubgroupsStaticLoad(char **row, struct samplesInSubgroups *ret);
/* Load a row from samplesInSubgroups table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct samplesInSubgroups *samplesInSubgroupsLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all samplesInSubgroups from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with samplesInSubgroupsFreeList(). */

void samplesInSubgroupsSaveToDb(struct sqlConnection *conn, struct samplesInSubgroups *el, char *tableName, int updateSize);
/* Save samplesInSubgroups as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use samplesInSubgroupsSaveToDbEscaped() */

void samplesInSubgroupsSaveToDbEscaped(struct sqlConnection *conn, struct samplesInSubgroups *el, char *tableName, int updateSize);
/* Save samplesInSubgroups as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than samplesInSubgroupsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct samplesInSubgroups *samplesInSubgroupsLoad(char **row);
/* Load a samplesInSubgroups from row fetched with select * from samplesInSubgroups
 * from database.  Dispose of this with samplesInSubgroupsFree(). */

struct samplesInSubgroups *samplesInSubgroupsLoadAll(char *fileName);
/* Load all samplesInSubgroups from whitespace-separated file.
 * Dispose of this with samplesInSubgroupsFreeList(). */

struct samplesInSubgroups *samplesInSubgroupsLoadAllByChar(char *fileName, char chopper);
/* Load all samplesInSubgroups from chopper separated file.
 * Dispose of this with samplesInSubgroupsFreeList(). */

#define samplesInSubgroupsLoadAllByTab(a) samplesInSubgroupsLoadAllByChar(a, '\t');
/* Load all samplesInSubgroups from tab separated file.
 * Dispose of this with samplesInSubgroupsFreeList(). */

struct samplesInSubgroups *samplesInSubgroupsCommaIn(char **pS, struct samplesInSubgroups *ret);
/* Create a samplesInSubgroups out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new samplesInSubgroups */

void samplesInSubgroupsFree(struct samplesInSubgroups **pEl);
/* Free a single dynamically allocated samplesInSubgroups such as created
 * with samplesInSubgroupsLoad(). */

void samplesInSubgroupsFreeList(struct samplesInSubgroups **pList);
/* Free a list of dynamically allocated samplesInSubgroups's */

void samplesInSubgroupsOutput(struct samplesInSubgroups *el, FILE *f, char sep, char lastSep);
/* Print out samplesInSubgroups.  Separate fields with sep. Follow last field with lastSep. */

#define samplesInSubgroupsTabOut(el,f) samplesInSubgroupsOutput(el,f,'\t','\n');
/* Print out samplesInSubgroups as a line in a tab-separated file. */

#define samplesInSubgroupsCommaOut(el,f) samplesInSubgroupsOutput(el,f,',',',');
/* Print out samplesInSubgroups as a comma separated list including final comma. */

void samplesInSubgroupsJsonOutput(struct samplesInSubgroups *el, FILE *f);
/* Print out samplesInSubgroups in JSON format. */

#define FEATURESELECTIONS_NUM_COLS 5

struct featureSelections
/* Names and parameters for feature select methods in machine learning */
    {
    struct featureSelections *next;  /* Next in singly linked list. */
    unsigned id;	/* featureSelections id (auto_increment) */
    char *name;	/* Name of feature selection algorithm */
    char *parameters;	/* Parameters used to run feature selection */
    unsigned datasets_id;	/* Dataset this feature selection was applied to */
    unsigned featureCount;	/* Number of features after feature selection */
    };

void featureSelectionsStaticLoad(char **row, struct featureSelections *ret);
/* Load a row from featureSelections table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct featureSelections *featureSelectionsLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all featureSelections from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with featureSelectionsFreeList(). */

void featureSelectionsSaveToDb(struct sqlConnection *conn, struct featureSelections *el, char *tableName, int updateSize);
/* Save featureSelections as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use featureSelectionsSaveToDbEscaped() */

void featureSelectionsSaveToDbEscaped(struct sqlConnection *conn, struct featureSelections *el, char *tableName, int updateSize);
/* Save featureSelections as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than featureSelectionsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct featureSelections *featureSelectionsLoad(char **row);
/* Load a featureSelections from row fetched with select * from featureSelections
 * from database.  Dispose of this with featureSelectionsFree(). */

struct featureSelections *featureSelectionsLoadAll(char *fileName);
/* Load all featureSelections from whitespace-separated file.
 * Dispose of this with featureSelectionsFreeList(). */

struct featureSelections *featureSelectionsLoadAllByChar(char *fileName, char chopper);
/* Load all featureSelections from chopper separated file.
 * Dispose of this with featureSelectionsFreeList(). */

#define featureSelectionsLoadAllByTab(a) featureSelectionsLoadAllByChar(a, '\t');
/* Load all featureSelections from tab separated file.
 * Dispose of this with featureSelectionsFreeList(). */

struct featureSelections *featureSelectionsCommaIn(char **pS, struct featureSelections *ret);
/* Create a featureSelections out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new featureSelections */

void featureSelectionsFree(struct featureSelections **pEl);
/* Free a single dynamically allocated featureSelections such as created
 * with featureSelectionsLoad(). */

void featureSelectionsFreeList(struct featureSelections **pList);
/* Free a list of dynamically allocated featureSelections's */

void featureSelectionsOutput(struct featureSelections *el, FILE *f, char sep, char lastSep);
/* Print out featureSelections.  Separate fields with sep. Follow last field with lastSep. */

#define featureSelectionsTabOut(el,f) featureSelectionsOutput(el,f,'\t','\n');
/* Print out featureSelections as a line in a tab-separated file. */

#define featureSelectionsCommaOut(el,f) featureSelectionsOutput(el,f,',',',');
/* Print out featureSelections as a comma separated list including final comma. */

void featureSelectionsJsonOutput(struct featureSelections *el, FILE *f);
/* Print out featureSelections in JSON format. */

#define TRANSFORMATIONS_NUM_COLS 3

struct transformations
/* Names and parameters for data transformation methods in machine learning */
    {
    struct transformations *next;  /* Next in singly linked list. */
    unsigned id;	/* featureSelections id (auto_increment) */
    char *name;	/* Name of feature selection algorithm */
    char *parameters;	/* Parameters used to run feature selection */
    };

void transformationsStaticLoad(char **row, struct transformations *ret);
/* Load a row from transformations table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct transformations *transformationsLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all transformations from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with transformationsFreeList(). */

void transformationsSaveToDb(struct sqlConnection *conn, struct transformations *el, char *tableName, int updateSize);
/* Save transformations as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use transformationsSaveToDbEscaped() */

void transformationsSaveToDbEscaped(struct sqlConnection *conn, struct transformations *el, char *tableName, int updateSize);
/* Save transformations as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than transformationsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct transformations *transformationsLoad(char **row);
/* Load a transformations from row fetched with select * from transformations
 * from database.  Dispose of this with transformationsFree(). */

struct transformations *transformationsLoadAll(char *fileName);
/* Load all transformations from whitespace-separated file.
 * Dispose of this with transformationsFreeList(). */

struct transformations *transformationsLoadAllByChar(char *fileName, char chopper);
/* Load all transformations from chopper separated file.
 * Dispose of this with transformationsFreeList(). */

#define transformationsLoadAllByTab(a) transformationsLoadAllByChar(a, '\t');
/* Load all transformations from tab separated file.
 * Dispose of this with transformationsFreeList(). */

struct transformations *transformationsCommaIn(char **pS, struct transformations *ret);
/* Create a transformations out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new transformations */

void transformationsFree(struct transformations **pEl);
/* Free a single dynamically allocated transformations such as created
 * with transformationsLoad(). */

void transformationsFreeList(struct transformations **pList);
/* Free a list of dynamically allocated transformations's */

void transformationsOutput(struct transformations *el, FILE *f, char sep, char lastSep);
/* Print out transformations.  Separate fields with sep. Follow last field with lastSep. */

#define transformationsTabOut(el,f) transformationsOutput(el,f,'\t','\n');
/* Print out transformations as a line in a tab-separated file. */

#define transformationsCommaOut(el,f) transformationsOutput(el,f,',',',');
/* Print out transformations as a comma separated list including final comma. */

void transformationsJsonOutput(struct transformations *el, FILE *f);
/* Print out transformations in JSON format. */

#define REQUESTQUEUE_NUM_COLS 7

struct requestQueue
/* Queue of jobs to run in MLpipeline submitted via the online requester */
    {
    struct requestQueue *next;  /* Next in singly linked list. */
    unsigned id;	/* requestQueue id (auto_increment) */
    unsigned usrConfig_id;	/* id of the config associated with this queue item */
    char *status;	/* status of the request (1=unprocessed, 2=processing, 3=processed, 4=error) */
    double estimatedRunTime;	/* Estimated time in seconds for this run to complete after submission */
    char *submissionTime;	/* Time submission was saved to db */
    char *runBeginTime;	/* Time the job started running */
    char *runEndTime;	/* Time the job finished running */
    };

void requestQueueStaticLoad(char **row, struct requestQueue *ret);
/* Load a row from requestQueue table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct requestQueue *requestQueueLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all requestQueue from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with requestQueueFreeList(). */

void requestQueueSaveToDb(struct sqlConnection *conn, struct requestQueue *el, char *tableName, int updateSize);
/* Save requestQueue as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use requestQueueSaveToDbEscaped() */

void requestQueueSaveToDbEscaped(struct sqlConnection *conn, struct requestQueue *el, char *tableName, int updateSize);
/* Save requestQueue as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than requestQueueSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct requestQueue *requestQueueLoad(char **row);
/* Load a requestQueue from row fetched with select * from requestQueue
 * from database.  Dispose of this with requestQueueFree(). */

struct requestQueue *requestQueueLoadAll(char *fileName);
/* Load all requestQueue from whitespace-separated file.
 * Dispose of this with requestQueueFreeList(). */

struct requestQueue *requestQueueLoadAllByChar(char *fileName, char chopper);
/* Load all requestQueue from chopper separated file.
 * Dispose of this with requestQueueFreeList(). */

#define requestQueueLoadAllByTab(a) requestQueueLoadAllByChar(a, '\t');
/* Load all requestQueue from tab separated file.
 * Dispose of this with requestQueueFreeList(). */

struct requestQueue *requestQueueCommaIn(char **pS, struct requestQueue *ret);
/* Create a requestQueue out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new requestQueue */

void requestQueueFree(struct requestQueue **pEl);
/* Free a single dynamically allocated requestQueue such as created
 * with requestQueueLoad(). */

void requestQueueFreeList(struct requestQueue **pList);
/* Free a list of dynamically allocated requestQueue's */

void requestQueueOutput(struct requestQueue *el, FILE *f, char sep, char lastSep);
/* Print out requestQueue.  Separate fields with sep. Follow last field with lastSep. */

#define requestQueueTabOut(el,f) requestQueueOutput(el,f,'\t','\n');
/* Print out requestQueue as a line in a tab-separated file. */

#define requestQueueCommaOut(el,f) requestQueueOutput(el,f,',',',');
/* Print out requestQueue as a comma separated list including final comma. */

void requestQueueJsonOutput(struct requestQueue *el, FILE *f);
/* Print out requestQueue in JSON format. */

#define USRCONFIG_NUM_COLS 27

struct usrConfig
/* Table of fields in user submitted machine-learning configurations */
    {
    struct usrConfig *next;  /* Next in singly linked list. */
    unsigned id;	/* usrConfig id (auto_increment) */
    char *profile;	/* Connection profile to use to get and store data */
    char *db;	/* Database to use to get and store data */
    char *classifiersRootDir;	/* Location on disk to find the classifiers installed */
    char *clusterJobPrefix;	/* Path and name space to store tmp files for classification */
    char *task;	/* Name of the task being predicted */
    char *inputType;	/* Type of input (default bioInt) */
    char *dataTableName;	/* Name of table to use (if inputType=bioInt) */
    char *clinField;	/* Clinical variable to predict (if inputType=bioInt) */
    char *dataFilepath;	/* Path to genomic data file (if inputType=flatfiles) */
    char *metadataFilepath;	/* Path to clinical data file (if inputType=flatfiles) */
    char *trainingDir;	/* Where to store training files */
    char *validationDir;	/* Where to store validation files */
    char *modelDir;	/* Where to store model files */
    char *crossValidation;	/* crossValidation type */
    unsigned folds;	/* Number of folds to use (if crossValidation=k-fold or loo) */
    unsigned foldMultiplier;	/* Number of times to repeat crossValidation */
    char *classifier;	/* Classifier to use */
    char *outputType;	/* File format to feed classifier */
    char *parameters;	/* Classifier parameters */
    char *dataDiscretizer;	/* Data transformation to use */
    char *dataDiscretizerParameters;	/* Parameters for data transformation */
    char *clinDiscretizer;	/* Subgrouping style to use */
    char *clinDiscretizerParameters;	/* Subgrouping parameters */
    char *featureSelection;	/* Feature selection to use */
    char *featureSelectionParameters;	/* feature select parameters */
    char *modelPath;	/* Path to the fully trained model */
    };

void usrConfigStaticLoad(char **row, struct usrConfig *ret);
/* Load a row from usrConfig table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct usrConfig *usrConfigLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all usrConfig from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with usrConfigFreeList(). */

void usrConfigSaveToDb(struct sqlConnection *conn, struct usrConfig *el, char *tableName, int updateSize);
/* Save usrConfig as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use usrConfigSaveToDbEscaped() */

void usrConfigSaveToDbEscaped(struct sqlConnection *conn, struct usrConfig *el, char *tableName, int updateSize);
/* Save usrConfig as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than usrConfigSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct usrConfig *usrConfigLoad(char **row);
/* Load a usrConfig from row fetched with select * from usrConfig
 * from database.  Dispose of this with usrConfigFree(). */

struct usrConfig *usrConfigLoadAll(char *fileName);
/* Load all usrConfig from whitespace-separated file.
 * Dispose of this with usrConfigFreeList(). */

struct usrConfig *usrConfigLoadAllByChar(char *fileName, char chopper);
/* Load all usrConfig from chopper separated file.
 * Dispose of this with usrConfigFreeList(). */

#define usrConfigLoadAllByTab(a) usrConfigLoadAllByChar(a, '\t');
/* Load all usrConfig from tab separated file.
 * Dispose of this with usrConfigFreeList(). */

struct usrConfig *usrConfigCommaIn(char **pS, struct usrConfig *ret);
/* Create a usrConfig out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new usrConfig */

void usrConfigFree(struct usrConfig **pEl);
/* Free a single dynamically allocated usrConfig such as created
 * with usrConfigLoad(). */

void usrConfigFreeList(struct usrConfig **pList);
/* Free a list of dynamically allocated usrConfig's */

void usrConfigOutput(struct usrConfig *el, FILE *f, char sep, char lastSep);
/* Print out usrConfig.  Separate fields with sep. Follow last field with lastSep. */

#define usrConfigTabOut(el,f) usrConfigOutput(el,f,'\t','\n');
/* Print out usrConfig as a line in a tab-separated file. */

#define usrConfigCommaOut(el,f) usrConfigOutput(el,f,',',',');
/* Print out usrConfig as a comma separated list including final comma. */

void usrConfigJsonOutput(struct usrConfig *el, FILE *f);
/* Print out usrConfig in JSON format. */

#define BACKGROUNDMODELSCORES_NUM_COLS 9

struct backgroundModelScores
/* Table of values found when applying top models to background dataset */
    {
    struct backgroundModelScores *next;  /* Next in singly linked list. */
    unsigned id;	/* backgroundModelScores id (auto_increment) */
    unsigned jobs_id;	/* id of job this score set comes from */
    char *data_table;	/* Background dataset used */
    float max;	/* Max score from background dataset */
    float mean;	/* Average score from background dataset */
    float median;	/* Median score from background dataset */
    float sd;	/* Standard deviation from scores applied to background dataset */
    float min;	/* Minimum score when applied to background dataset */
    unsigned estimatedRunTime;	/* Time taken to run background data through model */
    };

void backgroundModelScoresStaticLoad(char **row, struct backgroundModelScores *ret);
/* Load a row from backgroundModelScores table into ret.  The contents of ret will
 * be replaced at the next call to this function. */

struct backgroundModelScores *backgroundModelScoresLoadByQuery(struct sqlConnection *conn, char *query);
/* Load all backgroundModelScores from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with backgroundModelScoresFreeList(). */

void backgroundModelScoresSaveToDb(struct sqlConnection *conn, struct backgroundModelScores *el, char *tableName, int updateSize);
/* Save backgroundModelScores as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use backgroundModelScoresSaveToDbEscaped() */

void backgroundModelScoresSaveToDbEscaped(struct sqlConnection *conn, struct backgroundModelScores *el, char *tableName, int updateSize);
/* Save backgroundModelScores as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than backgroundModelScoresSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 

struct backgroundModelScores *backgroundModelScoresLoad(char **row);
/* Load a backgroundModelScores from row fetched with select * from backgroundModelScores
 * from database.  Dispose of this with backgroundModelScoresFree(). */

struct backgroundModelScores *backgroundModelScoresLoadAll(char *fileName);
/* Load all backgroundModelScores from whitespace-separated file.
 * Dispose of this with backgroundModelScoresFreeList(). */

struct backgroundModelScores *backgroundModelScoresLoadAllByChar(char *fileName, char chopper);
/* Load all backgroundModelScores from chopper separated file.
 * Dispose of this with backgroundModelScoresFreeList(). */

#define backgroundModelScoresLoadAllByTab(a) backgroundModelScoresLoadAllByChar(a, '\t');
/* Load all backgroundModelScores from tab separated file.
 * Dispose of this with backgroundModelScoresFreeList(). */

struct backgroundModelScores *backgroundModelScoresCommaIn(char **pS, struct backgroundModelScores *ret);
/* Create a backgroundModelScores out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new backgroundModelScores */

void backgroundModelScoresFree(struct backgroundModelScores **pEl);
/* Free a single dynamically allocated backgroundModelScores such as created
 * with backgroundModelScoresLoad(). */

void backgroundModelScoresFreeList(struct backgroundModelScores **pList);
/* Free a list of dynamically allocated backgroundModelScores's */

void backgroundModelScoresOutput(struct backgroundModelScores *el, FILE *f, char sep, char lastSep);
/* Print out backgroundModelScores.  Separate fields with sep. Follow last field with lastSep. */

#define backgroundModelScoresTabOut(el,f) backgroundModelScoresOutput(el,f,'\t','\n');
/* Print out backgroundModelScores as a line in a tab-separated file. */

#define backgroundModelScoresCommaOut(el,f) backgroundModelScoresOutput(el,f,',',',');
/* Print out backgroundModelScores as a comma separated list including final comma. */

void backgroundModelScoresJsonOutput(struct backgroundModelScores *el, FILE *f);
/* Print out backgroundModelScores in JSON format. */

/* -------------------------------- End autoSql Generated Code -------------------------------- */

#endif /* CLASSIFICATIONTABLES_H */

