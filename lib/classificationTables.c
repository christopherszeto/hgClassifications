/* classificationTables.c was originally generated by the autoSql program, which also 
 * generated classificationTables.h and classificationTables.sql.  This module links the database and
 * the RAM representation of objects. */

#include "common.h"
#include "linefile.h"
#include "dystring.h"
#include "jksql.h"
#include "../inc/classificationTables.h"

static char const rcsid[] = "$Id:$";

void jobsStaticLoad(char **row, struct jobs *ret)
/* Load a row from jobs table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->datasets_id = sqlUnsigned(row[1]);
ret->tasks_id = sqlUnsigned(row[2]);
ret->classifiers_id = sqlUnsigned(row[3]);
ret->featureSelections_id = sqlUnsigned(row[4]);
ret->transformations_id = sqlUnsigned(row[5]);
ret->subgroups_id = sqlUnsigned(row[6]);
ret->avgTestingAccuracy = sqlFloat(row[7]);
ret->avgTestingAccuracyGain = sqlFloat(row[8]);
ret->accuracyType = row[9];
ret->features = row[10];
ret->weights = row[11];
ret->modelPath = row[12];
}

struct jobs *jobsLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all jobs from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with jobsFreeList(). */
{
struct jobs *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = jobsLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void jobsSaveToDb(struct sqlConnection *conn, struct jobs *el, char *tableName, int updateSize)
/* Save jobs as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use jobsSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,%u,%u,%u,%u,%u,%u,%g,%g,'%s','%s','%s','%s')", 
	tableName,  el->id,  el->datasets_id,  el->tasks_id,  el->classifiers_id,  el->featureSelections_id,  el->transformations_id,  el->subgroups_id,  el->avgTestingAccuracy,  el->avgTestingAccuracyGain,  el->accuracyType,  el->features,  el->weights,  el->modelPath);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void jobsSaveToDbEscaped(struct sqlConnection *conn, struct jobs *el, char *tableName, int updateSize)
/* Save jobs as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than jobsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *accuracyType, *features, *weights, *modelPath;
accuracyType = sqlEscapeString(el->accuracyType);
features = sqlEscapeString(el->features);
weights = sqlEscapeString(el->weights);
modelPath = sqlEscapeString(el->modelPath);

dyStringPrintf(update, "insert into %s values ( %u,%u,%u,%u,%u,%u,%u,%g,%g,'%s','%s','%s','%s')", 
	tableName,  el->id,  el->datasets_id,  el->tasks_id,  el->classifiers_id,  el->featureSelections_id,  el->transformations_id,  el->subgroups_id,  el->avgTestingAccuracy,  el->avgTestingAccuracyGain,  accuracyType,  features,  weights,  modelPath);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&accuracyType);
freez(&features);
freez(&weights);
freez(&modelPath);
}

struct jobs *jobsLoad(char **row)
/* Load a jobs from row fetched with select * from jobs
 * from database.  Dispose of this with jobsFree(). */
{
struct jobs *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->datasets_id = sqlUnsigned(row[1]);
ret->tasks_id = sqlUnsigned(row[2]);
ret->classifiers_id = sqlUnsigned(row[3]);
ret->featureSelections_id = sqlUnsigned(row[4]);
ret->transformations_id = sqlUnsigned(row[5]);
ret->subgroups_id = sqlUnsigned(row[6]);
ret->avgTestingAccuracy = sqlFloat(row[7]);
ret->avgTestingAccuracyGain = sqlFloat(row[8]);
ret->accuracyType = cloneString(row[9]);
ret->features = cloneString(row[10]);
ret->weights = cloneString(row[11]);
ret->modelPath = cloneString(row[12]);
return ret;
}

struct jobs *jobsLoadAll(char *fileName) 
/* Load all jobs from a whitespace-separated file.
 * Dispose of this with jobsFreeList(). */
{
struct jobs *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[13];

while (lineFileRow(lf, row))
    {
    el = jobsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct jobs *jobsLoadAllByChar(char *fileName, char chopper) 
/* Load all jobs from a chopper separated file.
 * Dispose of this with jobsFreeList(). */
{
struct jobs *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[13];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = jobsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct jobs *jobsCommaIn(char **pS, struct jobs *ret)
/* Create a jobs out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new jobs */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->datasets_id = sqlUnsignedComma(&s);
ret->tasks_id = sqlUnsignedComma(&s);
ret->classifiers_id = sqlUnsignedComma(&s);
ret->featureSelections_id = sqlUnsignedComma(&s);
ret->transformations_id = sqlUnsignedComma(&s);
ret->subgroups_id = sqlUnsignedComma(&s);
ret->avgTestingAccuracy = sqlFloatComma(&s);
ret->avgTestingAccuracyGain = sqlFloatComma(&s);
ret->accuracyType = sqlStringComma(&s);
ret->features = sqlStringComma(&s);
ret->weights = sqlStringComma(&s);
ret->modelPath = sqlStringComma(&s);
*pS = s;
return ret;
}

void jobsFree(struct jobs **pEl)
/* Free a single dynamically allocated jobs such as created
 * with jobsLoad(). */
{
struct jobs *el;

if ((el = *pEl) == NULL) return;
freeMem(el->accuracyType);
freeMem(el->features);
freeMem(el->weights);
freeMem(el->modelPath);
freez(pEl);
}

void jobsFreeList(struct jobs **pList)
/* Free a list of dynamically allocated jobs's */
{
struct jobs *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    jobsFree(&el);
    }
*pList = NULL;
}

void jobsOutput(struct jobs *el, FILE *f, char sep, char lastSep) 
/* Print out jobs.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->datasets_id);
fputc(sep,f);
fprintf(f, "%u", el->tasks_id);
fputc(sep,f);
fprintf(f, "%u", el->classifiers_id);
fputc(sep,f);
fprintf(f, "%u", el->featureSelections_id);
fputc(sep,f);
fprintf(f, "%u", el->transformations_id);
fputc(sep,f);
fprintf(f, "%u", el->subgroups_id);
fputc(sep,f);
fprintf(f, "%g", el->avgTestingAccuracy);
fputc(sep,f);
fprintf(f, "%g", el->avgTestingAccuracyGain);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->accuracyType);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->features);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->weights);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->modelPath);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void jobsJsonOutput(struct jobs *el, FILE *f) 
/* Print out jobs in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"datasets_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->datasets_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"tasks_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->tasks_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"classifiers_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->classifiers_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"featureSelections_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->featureSelections_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"transformations_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->transformations_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"subgroups_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->subgroups_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"avgTestingAccuracy");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->avgTestingAccuracy);
fputc(',',f);
fputc('"',f);
fprintf(f,"avgTestingAccuracyGain");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->avgTestingAccuracyGain);
fputc(',',f);
fputc('"',f);
fprintf(f,"accuracyType");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->accuracyType);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"features");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->features);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"weights");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->weights);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"modelPath");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->modelPath);
fputc('"',f);
fputc('}',f);
}

void tasksStaticLoad(char **row, struct tasks *ret)
/* Load a row from tasks table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
}

struct tasks *tasksLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all tasks from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with tasksFreeList(). */
{
struct tasks *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = tasksLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void tasksSaveToDb(struct sqlConnection *conn, struct tasks *el, char *tableName, int updateSize)
/* Save tasks as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use tasksSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s')", 
	tableName,  el->id,  el->name);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void tasksSaveToDbEscaped(struct sqlConnection *conn, struct tasks *el, char *tableName, int updateSize)
/* Save tasks as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than tasksSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *name;
name = sqlEscapeString(el->name);

dyStringPrintf(update, "insert into %s values ( %u,'%s')", 
	tableName,  el->id,  name);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&name);
}

struct tasks *tasksLoad(char **row)
/* Load a tasks from row fetched with select * from tasks
 * from database.  Dispose of this with tasksFree(). */
{
struct tasks *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
return ret;
}

struct tasks *tasksLoadAll(char *fileName) 
/* Load all tasks from a whitespace-separated file.
 * Dispose of this with tasksFreeList(). */
{
struct tasks *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileRow(lf, row))
    {
    el = tasksLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct tasks *tasksLoadAllByChar(char *fileName, char chopper) 
/* Load all tasks from a chopper separated file.
 * Dispose of this with tasksFreeList(). */
{
struct tasks *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[2];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = tasksLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct tasks *tasksCommaIn(char **pS, struct tasks *ret)
/* Create a tasks out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new tasks */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
*pS = s;
return ret;
}

void tasksFree(struct tasks **pEl)
/* Free a single dynamically allocated tasks such as created
 * with tasksLoad(). */
{
struct tasks *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freez(pEl);
}

void tasksFreeList(struct tasks **pList)
/* Free a list of dynamically allocated tasks's */
{
struct tasks *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    tasksFree(&el);
    }
*pList = NULL;
}

void tasksOutput(struct tasks *el, FILE *f, char sep, char lastSep) 
/* Print out tasks.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void tasksJsonOutput(struct tasks *el, FILE *f) 
/* Print out tasks in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"name");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->name);
fputc('"',f);
fputc('}',f);
}

void classifiersStaticLoad(char **row, struct classifiers *ret)
/* Load a row from classifiers table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->parameters = row[2];
}

struct classifiers *classifiersLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all classifiers from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with classifiersFreeList(). */
{
struct classifiers *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = classifiersLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void classifiersSaveToDb(struct sqlConnection *conn, struct classifiers *el, char *tableName, int updateSize)
/* Save classifiers as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use classifiersSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s','%s')", 
	tableName,  el->id,  el->name,  el->parameters);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void classifiersSaveToDbEscaped(struct sqlConnection *conn, struct classifiers *el, char *tableName, int updateSize)
/* Save classifiers as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than classifiersSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *name, *parameters;
name = sqlEscapeString(el->name);
parameters = sqlEscapeString(el->parameters);

dyStringPrintf(update, "insert into %s values ( %u,'%s','%s')", 
	tableName,  el->id,  name,  parameters);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&name);
freez(&parameters);
}

struct classifiers *classifiersLoad(char **row)
/* Load a classifiers from row fetched with select * from classifiers
 * from database.  Dispose of this with classifiersFree(). */
{
struct classifiers *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->parameters = cloneString(row[2]);
return ret;
}

struct classifiers *classifiersLoadAll(char *fileName) 
/* Load all classifiers from a whitespace-separated file.
 * Dispose of this with classifiersFreeList(). */
{
struct classifiers *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = classifiersLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct classifiers *classifiersLoadAllByChar(char *fileName, char chopper) 
/* Load all classifiers from a chopper separated file.
 * Dispose of this with classifiersFreeList(). */
{
struct classifiers *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = classifiersLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct classifiers *classifiersCommaIn(char **pS, struct classifiers *ret)
/* Create a classifiers out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new classifiers */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->parameters = sqlStringComma(&s);
*pS = s;
return ret;
}

void classifiersFree(struct classifiers **pEl)
/* Free a single dynamically allocated classifiers such as created
 * with classifiersLoad(). */
{
struct classifiers *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->parameters);
freez(pEl);
}

void classifiersFreeList(struct classifiers **pList)
/* Free a list of dynamically allocated classifiers's */
{
struct classifiers *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    classifiersFree(&el);
    }
*pList = NULL;
}

void classifiersOutput(struct classifiers *el, FILE *f, char sep, char lastSep) 
/* Print out classifiers.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->parameters);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void classifiersJsonOutput(struct classifiers *el, FILE *f) 
/* Print out classifiers in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"name");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->name);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"parameters");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->parameters);
fputc('"',f);
fputc('}',f);
}

void classifierResultsStaticLoad(char **row, struct classifierResults *ret)
/* Load a row from classifierResults table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->tasks_id = sqlUnsigned(row[1]);
ret->jobs_id = sqlUnsigned(row[2]);
ret->sample_id = sqlUnsigned(row[3]);
ret->trainingAccuracy = sqlFloat(row[4]);
ret->testingAccuracy = sqlFloat(row[5]);
ret->predictionScore = sqlFloat(row[6]);
}

struct classifierResults *classifierResultsLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all classifierResults from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with classifierResultsFreeList(). */
{
struct classifierResults *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = classifierResultsLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void classifierResultsSaveToDb(struct sqlConnection *conn, struct classifierResults *el, char *tableName, int updateSize)
/* Save classifierResults as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use classifierResultsSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,%u,%u,%u,%g,%g,%g)", 
	tableName,  el->id,  el->tasks_id,  el->jobs_id,  el->sample_id,  el->trainingAccuracy,  el->testingAccuracy,  el->predictionScore);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void classifierResultsSaveToDbEscaped(struct sqlConnection *conn, struct classifierResults *el, char *tableName, int updateSize)
/* Save classifierResults as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than classifierResultsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,%u,%u,%u,%g,%g,%g)", 
	tableName,  el->id,  el->tasks_id,  el->jobs_id,  el->sample_id,  el->trainingAccuracy,  el->testingAccuracy,  el->predictionScore);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

struct classifierResults *classifierResultsLoad(char **row)
/* Load a classifierResults from row fetched with select * from classifierResults
 * from database.  Dispose of this with classifierResultsFree(). */
{
struct classifierResults *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->tasks_id = sqlUnsigned(row[1]);
ret->jobs_id = sqlUnsigned(row[2]);
ret->sample_id = sqlUnsigned(row[3]);
ret->trainingAccuracy = sqlFloat(row[4]);
ret->testingAccuracy = sqlFloat(row[5]);
ret->predictionScore = sqlFloat(row[6]);
return ret;
}

struct classifierResults *classifierResultsLoadAll(char *fileName) 
/* Load all classifierResults from a whitespace-separated file.
 * Dispose of this with classifierResultsFreeList(). */
{
struct classifierResults *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileRow(lf, row))
    {
    el = classifierResultsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct classifierResults *classifierResultsLoadAllByChar(char *fileName, char chopper) 
/* Load all classifierResults from a chopper separated file.
 * Dispose of this with classifierResultsFreeList(). */
{
struct classifierResults *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = classifierResultsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct classifierResults *classifierResultsCommaIn(char **pS, struct classifierResults *ret)
/* Create a classifierResults out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new classifierResults */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->tasks_id = sqlUnsignedComma(&s);
ret->jobs_id = sqlUnsignedComma(&s);
ret->sample_id = sqlUnsignedComma(&s);
ret->trainingAccuracy = sqlFloatComma(&s);
ret->testingAccuracy = sqlFloatComma(&s);
ret->predictionScore = sqlFloatComma(&s);
*pS = s;
return ret;
}

void classifierResultsFree(struct classifierResults **pEl)
/* Free a single dynamically allocated classifierResults such as created
 * with classifierResultsLoad(). */
{
struct classifierResults *el;

if ((el = *pEl) == NULL) return;
freez(pEl);
}

void classifierResultsFreeList(struct classifierResults **pList)
/* Free a list of dynamically allocated classifierResults's */
{
struct classifierResults *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    classifierResultsFree(&el);
    }
*pList = NULL;
}

void classifierResultsOutput(struct classifierResults *el, FILE *f, char sep, char lastSep) 
/* Print out classifierResults.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->tasks_id);
fputc(sep,f);
fprintf(f, "%u", el->jobs_id);
fputc(sep,f);
fprintf(f, "%u", el->sample_id);
fputc(sep,f);
fprintf(f, "%g", el->trainingAccuracy);
fputc(sep,f);
fprintf(f, "%g", el->testingAccuracy);
fputc(sep,f);
fprintf(f, "%g", el->predictionScore);
fputc(lastSep,f);
}

void classifierResultsJsonOutput(struct classifierResults *el, FILE *f) 
/* Print out classifierResults in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"tasks_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->tasks_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"jobs_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->jobs_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"sample_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->sample_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"trainingAccuracy");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->trainingAccuracy);
fputc(',',f);
fputc('"',f);
fprintf(f,"testingAccuracy");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->testingAccuracy);
fputc(',',f);
fputc('"',f);
fprintf(f,"predictionScore");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->predictionScore);
fputc('}',f);
}

void subgroupsStaticLoad(char **row, struct subgroups *ret)
/* Load a row from subgroups table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->parameters = row[2];
ret->datasets_id = sqlUnsigned(row[3]);
}

struct subgroups *subgroupsLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all subgroups from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with subgroupsFreeList(). */
{
struct subgroups *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = subgroupsLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void subgroupsSaveToDb(struct sqlConnection *conn, struct subgroups *el, char *tableName, int updateSize)
/* Save subgroups as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use subgroupsSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s','%s',%u)", 
	tableName,  el->id,  el->name,  el->parameters,  el->datasets_id);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void subgroupsSaveToDbEscaped(struct sqlConnection *conn, struct subgroups *el, char *tableName, int updateSize)
/* Save subgroups as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than subgroupsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *name, *parameters;
name = sqlEscapeString(el->name);
parameters = sqlEscapeString(el->parameters);

dyStringPrintf(update, "insert into %s values ( %u,'%s','%s',%u)", 
	tableName,  el->id,  name,  parameters,  el->datasets_id);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&name);
freez(&parameters);
}

struct subgroups *subgroupsLoad(char **row)
/* Load a subgroups from row fetched with select * from subgroups
 * from database.  Dispose of this with subgroupsFree(). */
{
struct subgroups *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->parameters = cloneString(row[2]);
ret->datasets_id = sqlUnsigned(row[3]);
return ret;
}

struct subgroups *subgroupsLoadAll(char *fileName) 
/* Load all subgroups from a whitespace-separated file.
 * Dispose of this with subgroupsFreeList(). */
{
struct subgroups *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = subgroupsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct subgroups *subgroupsLoadAllByChar(char *fileName, char chopper) 
/* Load all subgroups from a chopper separated file.
 * Dispose of this with subgroupsFreeList(). */
{
struct subgroups *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = subgroupsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct subgroups *subgroupsCommaIn(char **pS, struct subgroups *ret)
/* Create a subgroups out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new subgroups */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->parameters = sqlStringComma(&s);
ret->datasets_id = sqlUnsignedComma(&s);
*pS = s;
return ret;
}

void subgroupsFree(struct subgroups **pEl)
/* Free a single dynamically allocated subgroups such as created
 * with subgroupsLoad(). */
{
struct subgroups *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->parameters);
freez(pEl);
}

void subgroupsFreeList(struct subgroups **pList)
/* Free a list of dynamically allocated subgroups's */
{
struct subgroups *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    subgroupsFree(&el);
    }
*pList = NULL;
}

void subgroupsOutput(struct subgroups *el, FILE *f, char sep, char lastSep) 
/* Print out subgroups.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->parameters);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->datasets_id);
fputc(lastSep,f);
}

void subgroupsJsonOutput(struct subgroups *el, FILE *f) 
/* Print out subgroups in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"name");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->name);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"parameters");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->parameters);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"datasets_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->datasets_id);
fputc('}',f);
}

void samplesInSubgroupsStaticLoad(char **row, struct samplesInSubgroups *ret)
/* Load a row from samplesInSubgroups table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->subgroups_id = sqlUnsigned(row[1]);
ret->subgroup = sqlUnsigned(row[2]);
ret->sample_id = sqlUnsigned(row[3]);
}

struct samplesInSubgroups *samplesInSubgroupsLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all samplesInSubgroups from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with samplesInSubgroupsFreeList(). */
{
struct samplesInSubgroups *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = samplesInSubgroupsLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void samplesInSubgroupsSaveToDb(struct sqlConnection *conn, struct samplesInSubgroups *el, char *tableName, int updateSize)
/* Save samplesInSubgroups as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use samplesInSubgroupsSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,%u,%u,%u)", 
	tableName,  el->id,  el->subgroups_id,  el->subgroup,  el->sample_id);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void samplesInSubgroupsSaveToDbEscaped(struct sqlConnection *conn, struct samplesInSubgroups *el, char *tableName, int updateSize)
/* Save samplesInSubgroups as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than samplesInSubgroupsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,%u,%u,%u)", 
	tableName,  el->id,  el->subgroups_id,  el->subgroup,  el->sample_id);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

struct samplesInSubgroups *samplesInSubgroupsLoad(char **row)
/* Load a samplesInSubgroups from row fetched with select * from samplesInSubgroups
 * from database.  Dispose of this with samplesInSubgroupsFree(). */
{
struct samplesInSubgroups *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->subgroups_id = sqlUnsigned(row[1]);
ret->subgroup = sqlUnsigned(row[2]);
ret->sample_id = sqlUnsigned(row[3]);
return ret;
}

struct samplesInSubgroups *samplesInSubgroupsLoadAll(char *fileName) 
/* Load all samplesInSubgroups from a whitespace-separated file.
 * Dispose of this with samplesInSubgroupsFreeList(). */
{
struct samplesInSubgroups *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileRow(lf, row))
    {
    el = samplesInSubgroupsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct samplesInSubgroups *samplesInSubgroupsLoadAllByChar(char *fileName, char chopper) 
/* Load all samplesInSubgroups from a chopper separated file.
 * Dispose of this with samplesInSubgroupsFreeList(). */
{
struct samplesInSubgroups *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[4];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = samplesInSubgroupsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct samplesInSubgroups *samplesInSubgroupsCommaIn(char **pS, struct samplesInSubgroups *ret)
/* Create a samplesInSubgroups out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new samplesInSubgroups */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->subgroups_id = sqlUnsignedComma(&s);
ret->subgroup = sqlUnsignedComma(&s);
ret->sample_id = sqlUnsignedComma(&s);
*pS = s;
return ret;
}

void samplesInSubgroupsFree(struct samplesInSubgroups **pEl)
/* Free a single dynamically allocated samplesInSubgroups such as created
 * with samplesInSubgroupsLoad(). */
{
struct samplesInSubgroups *el;

if ((el = *pEl) == NULL) return;
freez(pEl);
}

void samplesInSubgroupsFreeList(struct samplesInSubgroups **pList)
/* Free a list of dynamically allocated samplesInSubgroups's */
{
struct samplesInSubgroups *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    samplesInSubgroupsFree(&el);
    }
*pList = NULL;
}

void samplesInSubgroupsOutput(struct samplesInSubgroups *el, FILE *f, char sep, char lastSep) 
/* Print out samplesInSubgroups.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->subgroups_id);
fputc(sep,f);
fprintf(f, "%u", el->subgroup);
fputc(sep,f);
fprintf(f, "%u", el->sample_id);
fputc(lastSep,f);
}

void samplesInSubgroupsJsonOutput(struct samplesInSubgroups *el, FILE *f) 
/* Print out samplesInSubgroups in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"subgroups_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->subgroups_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"subgroup");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->subgroup);
fputc(',',f);
fputc('"',f);
fprintf(f,"sample_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->sample_id);
fputc('}',f);
}

void featureSelectionsStaticLoad(char **row, struct featureSelections *ret)
/* Load a row from featureSelections table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->parameters = row[2];
ret->datasets_id = sqlUnsigned(row[3]);
ret->featureCount = sqlUnsigned(row[4]);
}

struct featureSelections *featureSelectionsLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all featureSelections from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with featureSelectionsFreeList(). */
{
struct featureSelections *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = featureSelectionsLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void featureSelectionsSaveToDb(struct sqlConnection *conn, struct featureSelections *el, char *tableName, int updateSize)
/* Save featureSelections as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use featureSelectionsSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s','%s',%u,%u)", 
	tableName,  el->id,  el->name,  el->parameters,  el->datasets_id,  el->featureCount);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void featureSelectionsSaveToDbEscaped(struct sqlConnection *conn, struct featureSelections *el, char *tableName, int updateSize)
/* Save featureSelections as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than featureSelectionsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *name, *parameters;
name = sqlEscapeString(el->name);
parameters = sqlEscapeString(el->parameters);

dyStringPrintf(update, "insert into %s values ( %u,'%s','%s',%u,%u)", 
	tableName,  el->id,  name,  parameters,  el->datasets_id,  el->featureCount);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&name);
freez(&parameters);
}

struct featureSelections *featureSelectionsLoad(char **row)
/* Load a featureSelections from row fetched with select * from featureSelections
 * from database.  Dispose of this with featureSelectionsFree(). */
{
struct featureSelections *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->parameters = cloneString(row[2]);
ret->datasets_id = sqlUnsigned(row[3]);
ret->featureCount = sqlUnsigned(row[4]);
return ret;
}

struct featureSelections *featureSelectionsLoadAll(char *fileName) 
/* Load all featureSelections from a whitespace-separated file.
 * Dispose of this with featureSelectionsFreeList(). */
{
struct featureSelections *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileRow(lf, row))
    {
    el = featureSelectionsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct featureSelections *featureSelectionsLoadAllByChar(char *fileName, char chopper) 
/* Load all featureSelections from a chopper separated file.
 * Dispose of this with featureSelectionsFreeList(). */
{
struct featureSelections *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[5];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = featureSelectionsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct featureSelections *featureSelectionsCommaIn(char **pS, struct featureSelections *ret)
/* Create a featureSelections out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new featureSelections */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->parameters = sqlStringComma(&s);
ret->datasets_id = sqlUnsignedComma(&s);
ret->featureCount = sqlUnsignedComma(&s);
*pS = s;
return ret;
}

void featureSelectionsFree(struct featureSelections **pEl)
/* Free a single dynamically allocated featureSelections such as created
 * with featureSelectionsLoad(). */
{
struct featureSelections *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->parameters);
freez(pEl);
}

void featureSelectionsFreeList(struct featureSelections **pList)
/* Free a list of dynamically allocated featureSelections's */
{
struct featureSelections *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    featureSelectionsFree(&el);
    }
*pList = NULL;
}

void featureSelectionsOutput(struct featureSelections *el, FILE *f, char sep, char lastSep) 
/* Print out featureSelections.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->parameters);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->datasets_id);
fputc(sep,f);
fprintf(f, "%u", el->featureCount);
fputc(lastSep,f);
}

void featureSelectionsJsonOutput(struct featureSelections *el, FILE *f) 
/* Print out featureSelections in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"name");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->name);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"parameters");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->parameters);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"datasets_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->datasets_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"featureCount");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->featureCount);
fputc('}',f);
}

void transformationsStaticLoad(char **row, struct transformations *ret)
/* Load a row from transformations table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->name = row[1];
ret->parameters = row[2];
}

struct transformations *transformationsLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all transformations from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with transformationsFreeList(). */
{
struct transformations *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = transformationsLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void transformationsSaveToDb(struct sqlConnection *conn, struct transformations *el, char *tableName, int updateSize)
/* Save transformations as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use transformationsSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s','%s')", 
	tableName,  el->id,  el->name,  el->parameters);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void transformationsSaveToDbEscaped(struct sqlConnection *conn, struct transformations *el, char *tableName, int updateSize)
/* Save transformations as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than transformationsSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *name, *parameters;
name = sqlEscapeString(el->name);
parameters = sqlEscapeString(el->parameters);

dyStringPrintf(update, "insert into %s values ( %u,'%s','%s')", 
	tableName,  el->id,  name,  parameters);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&name);
freez(&parameters);
}

struct transformations *transformationsLoad(char **row)
/* Load a transformations from row fetched with select * from transformations
 * from database.  Dispose of this with transformationsFree(). */
{
struct transformations *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->name = cloneString(row[1]);
ret->parameters = cloneString(row[2]);
return ret;
}

struct transformations *transformationsLoadAll(char *fileName) 
/* Load all transformations from a whitespace-separated file.
 * Dispose of this with transformationsFreeList(). */
{
struct transformations *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileRow(lf, row))
    {
    el = transformationsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct transformations *transformationsLoadAllByChar(char *fileName, char chopper) 
/* Load all transformations from a chopper separated file.
 * Dispose of this with transformationsFreeList(). */
{
struct transformations *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[3];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = transformationsLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct transformations *transformationsCommaIn(char **pS, struct transformations *ret)
/* Create a transformations out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new transformations */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->name = sqlStringComma(&s);
ret->parameters = sqlStringComma(&s);
*pS = s;
return ret;
}

void transformationsFree(struct transformations **pEl)
/* Free a single dynamically allocated transformations such as created
 * with transformationsLoad(). */
{
struct transformations *el;

if ((el = *pEl) == NULL) return;
freeMem(el->name);
freeMem(el->parameters);
freez(pEl);
}

void transformationsFreeList(struct transformations **pList)
/* Free a list of dynamically allocated transformations's */
{
struct transformations *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    transformationsFree(&el);
    }
*pList = NULL;
}

void transformationsOutput(struct transformations *el, FILE *f, char sep, char lastSep) 
/* Print out transformations.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->name);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->parameters);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void transformationsJsonOutput(struct transformations *el, FILE *f) 
/* Print out transformations in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"name");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->name);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"parameters");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->parameters);
fputc('"',f);
fputc('}',f);
}

void requestQueueStaticLoad(char **row, struct requestQueue *ret)
/* Load a row from requestQueue table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->usrConfig_id = sqlUnsigned(row[1]);
ret->status = row[2];
ret->estimatedRunTime = sqlDouble(row[3]);
ret->submissionTime = row[4];
ret->runBeginTime = row[5];
ret->runEndTime = row[6];
}

struct requestQueue *requestQueueLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all requestQueue from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with requestQueueFreeList(). */
{
struct requestQueue *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = requestQueueLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void requestQueueSaveToDb(struct sqlConnection *conn, struct requestQueue *el, char *tableName, int updateSize)
/* Save requestQueue as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use requestQueueSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,%u,'%s',%g,'%s','%s','%s')", 
	tableName,  el->id,  el->usrConfig_id,  el->status,  el->estimatedRunTime,  el->submissionTime,  el->runBeginTime,  el->runEndTime);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void requestQueueSaveToDbEscaped(struct sqlConnection *conn, struct requestQueue *el, char *tableName, int updateSize)
/* Save requestQueue as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than requestQueueSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *status, *submissionTime, *runBeginTime, *runEndTime;
status = sqlEscapeString(el->status);
submissionTime = sqlEscapeString(el->submissionTime);
runBeginTime = sqlEscapeString(el->runBeginTime);
runEndTime = sqlEscapeString(el->runEndTime);

dyStringPrintf(update, "insert into %s values ( %u,%u,'%s',%g,'%s','%s','%s')", 
	tableName,  el->id,  el->usrConfig_id,  status,  el->estimatedRunTime,  submissionTime,  runBeginTime,  runEndTime);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&status);
freez(&submissionTime);
freez(&runBeginTime);
freez(&runEndTime);
}

struct requestQueue *requestQueueLoad(char **row)
/* Load a requestQueue from row fetched with select * from requestQueue
 * from database.  Dispose of this with requestQueueFree(). */
{
struct requestQueue *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->usrConfig_id = sqlUnsigned(row[1]);
ret->status = cloneString(row[2]);
ret->estimatedRunTime = sqlDouble(row[3]);
ret->submissionTime = cloneString(row[4]);
ret->runBeginTime = cloneString(row[5]);
ret->runEndTime = cloneString(row[6]);
return ret;
}

struct requestQueue *requestQueueLoadAll(char *fileName) 
/* Load all requestQueue from a whitespace-separated file.
 * Dispose of this with requestQueueFreeList(). */
{
struct requestQueue *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileRow(lf, row))
    {
    el = requestQueueLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct requestQueue *requestQueueLoadAllByChar(char *fileName, char chopper) 
/* Load all requestQueue from a chopper separated file.
 * Dispose of this with requestQueueFreeList(). */
{
struct requestQueue *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[7];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = requestQueueLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct requestQueue *requestQueueCommaIn(char **pS, struct requestQueue *ret)
/* Create a requestQueue out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new requestQueue */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->usrConfig_id = sqlUnsignedComma(&s);
ret->status = sqlStringComma(&s);
ret->estimatedRunTime = sqlDoubleComma(&s);
ret->submissionTime = sqlStringComma(&s);
ret->runBeginTime = sqlStringComma(&s);
ret->runEndTime = sqlStringComma(&s);
*pS = s;
return ret;
}

void requestQueueFree(struct requestQueue **pEl)
/* Free a single dynamically allocated requestQueue such as created
 * with requestQueueLoad(). */
{
struct requestQueue *el;

if ((el = *pEl) == NULL) return;
freeMem(el->status);
freeMem(el->submissionTime);
freeMem(el->runBeginTime);
freeMem(el->runEndTime);
freez(pEl);
}

void requestQueueFreeList(struct requestQueue **pList)
/* Free a list of dynamically allocated requestQueue's */
{
struct requestQueue *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    requestQueueFree(&el);
    }
*pList = NULL;
}

void requestQueueOutput(struct requestQueue *el, FILE *f, char sep, char lastSep) 
/* Print out requestQueue.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->usrConfig_id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->status);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%g", el->estimatedRunTime);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->submissionTime);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->runBeginTime);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->runEndTime);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void requestQueueJsonOutput(struct requestQueue *el, FILE *f) 
/* Print out requestQueue in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"usrConfig_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->usrConfig_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"status");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->status);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"estimatedRunTime");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->estimatedRunTime);
fputc(',',f);
fputc('"',f);
fprintf(f,"submissionTime");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->submissionTime);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"runBeginTime");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->runBeginTime);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"runEndTime");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->runEndTime);
fputc('"',f);
fputc('}',f);
}

void usrConfigStaticLoad(char **row, struct usrConfig *ret)
/* Load a row from usrConfig table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->profile = row[1];
ret->db = row[2];
ret->classifiersRootDir = row[3];
ret->clusterJobPrefix = row[4];
ret->task = row[5];
ret->inputType = row[6];
ret->dataTableName = row[7];
ret->clinField = row[8];
ret->dataFilepath = row[9];
ret->metadataFilepath = row[10];
ret->trainingDir = row[11];
ret->validationDir = row[12];
ret->modelDir = row[13];
ret->crossValidation = row[14];
ret->folds = sqlUnsigned(row[15]);
ret->foldMultiplier = sqlUnsigned(row[16]);
ret->classifier = row[17];
ret->outputType = row[18];
ret->parameters = row[19];
ret->dataDiscretizer = row[20];
ret->dataDiscretizerParameters = row[21];
ret->clinDiscretizer = row[22];
ret->clinDiscretizerParameters = row[23];
ret->featureSelection = row[24];
ret->featureSelectionParameters = row[25];
ret->modelPath = row[26];
}

struct usrConfig *usrConfigLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all usrConfig from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with usrConfigFreeList(). */
{
struct usrConfig *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = usrConfigLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void usrConfigSaveToDb(struct sqlConnection *conn, struct usrConfig *el, char *tableName, int updateSize)
/* Save usrConfig as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use usrConfigSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,'%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s',%u,%u,'%s','%s','%s','%s','%s','%s','%s','%s','%s','%s')", 
	tableName,  el->id,  el->profile,  el->db,  el->classifiersRootDir,  el->clusterJobPrefix,  el->task,  el->inputType,  el->dataTableName,  el->clinField,  el->dataFilepath,  el->metadataFilepath,  el->trainingDir,  el->validationDir,  el->modelDir,  el->crossValidation,  el->folds,  el->foldMultiplier,  el->classifier,  el->outputType,  el->parameters,  el->dataDiscretizer,  el->dataDiscretizerParameters,  el->clinDiscretizer,  el->clinDiscretizerParameters,  el->featureSelection,  el->featureSelectionParameters,  el->modelPath);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void usrConfigSaveToDbEscaped(struct sqlConnection *conn, struct usrConfig *el, char *tableName, int updateSize)
/* Save usrConfig as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than usrConfigSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *profile, *db, *classifiersRootDir, *clusterJobPrefix, *task, *inputType, *dataTableName, *clinField, *dataFilepath, *metadataFilepath, *trainingDir, *validationDir, *modelDir, *crossValidation, *classifier, *outputType, *parameters, *dataDiscretizer, *dataDiscretizerParameters, *clinDiscretizer, *clinDiscretizerParameters, *featureSelection, *featureSelectionParameters, *modelPath;
profile = sqlEscapeString(el->profile);
db = sqlEscapeString(el->db);
classifiersRootDir = sqlEscapeString(el->classifiersRootDir);
clusterJobPrefix = sqlEscapeString(el->clusterJobPrefix);
task = sqlEscapeString(el->task);
inputType = sqlEscapeString(el->inputType);
dataTableName = sqlEscapeString(el->dataTableName);
clinField = sqlEscapeString(el->clinField);
dataFilepath = sqlEscapeString(el->dataFilepath);
metadataFilepath = sqlEscapeString(el->metadataFilepath);
trainingDir = sqlEscapeString(el->trainingDir);
validationDir = sqlEscapeString(el->validationDir);
modelDir = sqlEscapeString(el->modelDir);
crossValidation = sqlEscapeString(el->crossValidation);
classifier = sqlEscapeString(el->classifier);
outputType = sqlEscapeString(el->outputType);
parameters = sqlEscapeString(el->parameters);
dataDiscretizer = sqlEscapeString(el->dataDiscretizer);
dataDiscretizerParameters = sqlEscapeString(el->dataDiscretizerParameters);
clinDiscretizer = sqlEscapeString(el->clinDiscretizer);
clinDiscretizerParameters = sqlEscapeString(el->clinDiscretizerParameters);
featureSelection = sqlEscapeString(el->featureSelection);
featureSelectionParameters = sqlEscapeString(el->featureSelectionParameters);
modelPath = sqlEscapeString(el->modelPath);

dyStringPrintf(update, "insert into %s values ( %u,'%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s',%u,%u,'%s','%s','%s','%s','%s','%s','%s','%s','%s','%s')", 
	tableName,  el->id,  profile,  db,  classifiersRootDir,  clusterJobPrefix,  task,  inputType,  dataTableName,  clinField,  dataFilepath,  metadataFilepath,  trainingDir,  validationDir,  modelDir,  crossValidation,  el->folds,  el->foldMultiplier,  classifier,  outputType,  parameters,  dataDiscretizer,  dataDiscretizerParameters,  clinDiscretizer,  clinDiscretizerParameters,  featureSelection,  featureSelectionParameters,  modelPath);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&profile);
freez(&db);
freez(&classifiersRootDir);
freez(&clusterJobPrefix);
freez(&task);
freez(&inputType);
freez(&dataTableName);
freez(&clinField);
freez(&dataFilepath);
freez(&metadataFilepath);
freez(&trainingDir);
freez(&validationDir);
freez(&modelDir);
freez(&crossValidation);
freez(&classifier);
freez(&outputType);
freez(&parameters);
freez(&dataDiscretizer);
freez(&dataDiscretizerParameters);
freez(&clinDiscretizer);
freez(&clinDiscretizerParameters);
freez(&featureSelection);
freez(&featureSelectionParameters);
freez(&modelPath);
}

struct usrConfig *usrConfigLoad(char **row)
/* Load a usrConfig from row fetched with select * from usrConfig
 * from database.  Dispose of this with usrConfigFree(). */
{
struct usrConfig *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->profile = cloneString(row[1]);
ret->db = cloneString(row[2]);
ret->classifiersRootDir = cloneString(row[3]);
ret->clusterJobPrefix = cloneString(row[4]);
ret->task = cloneString(row[5]);
ret->inputType = cloneString(row[6]);
ret->dataTableName = cloneString(row[7]);
ret->clinField = cloneString(row[8]);
ret->dataFilepath = cloneString(row[9]);
ret->metadataFilepath = cloneString(row[10]);
ret->trainingDir = cloneString(row[11]);
ret->validationDir = cloneString(row[12]);
ret->modelDir = cloneString(row[13]);
ret->crossValidation = cloneString(row[14]);
ret->folds = sqlUnsigned(row[15]);
ret->foldMultiplier = sqlUnsigned(row[16]);
ret->classifier = cloneString(row[17]);
ret->outputType = cloneString(row[18]);
ret->parameters = cloneString(row[19]);
ret->dataDiscretizer = cloneString(row[20]);
ret->dataDiscretizerParameters = cloneString(row[21]);
ret->clinDiscretizer = cloneString(row[22]);
ret->clinDiscretizerParameters = cloneString(row[23]);
ret->featureSelection = cloneString(row[24]);
ret->featureSelectionParameters = cloneString(row[25]);
ret->modelPath = cloneString(row[26]);
return ret;
}

struct usrConfig *usrConfigLoadAll(char *fileName) 
/* Load all usrConfig from a whitespace-separated file.
 * Dispose of this with usrConfigFreeList(). */
{
struct usrConfig *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[27];

while (lineFileRow(lf, row))
    {
    el = usrConfigLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct usrConfig *usrConfigLoadAllByChar(char *fileName, char chopper) 
/* Load all usrConfig from a chopper separated file.
 * Dispose of this with usrConfigFreeList(). */
{
struct usrConfig *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[27];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = usrConfigLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct usrConfig *usrConfigCommaIn(char **pS, struct usrConfig *ret)
/* Create a usrConfig out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new usrConfig */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->profile = sqlStringComma(&s);
ret->db = sqlStringComma(&s);
ret->classifiersRootDir = sqlStringComma(&s);
ret->clusterJobPrefix = sqlStringComma(&s);
ret->task = sqlStringComma(&s);
ret->inputType = sqlStringComma(&s);
ret->dataTableName = sqlStringComma(&s);
ret->clinField = sqlStringComma(&s);
ret->dataFilepath = sqlStringComma(&s);
ret->metadataFilepath = sqlStringComma(&s);
ret->trainingDir = sqlStringComma(&s);
ret->validationDir = sqlStringComma(&s);
ret->modelDir = sqlStringComma(&s);
ret->crossValidation = sqlStringComma(&s);
ret->folds = sqlUnsignedComma(&s);
ret->foldMultiplier = sqlUnsignedComma(&s);
ret->classifier = sqlStringComma(&s);
ret->outputType = sqlStringComma(&s);
ret->parameters = sqlStringComma(&s);
ret->dataDiscretizer = sqlStringComma(&s);
ret->dataDiscretizerParameters = sqlStringComma(&s);
ret->clinDiscretizer = sqlStringComma(&s);
ret->clinDiscretizerParameters = sqlStringComma(&s);
ret->featureSelection = sqlStringComma(&s);
ret->featureSelectionParameters = sqlStringComma(&s);
ret->modelPath = sqlStringComma(&s);
*pS = s;
return ret;
}

void usrConfigFree(struct usrConfig **pEl)
/* Free a single dynamically allocated usrConfig such as created
 * with usrConfigLoad(). */
{
struct usrConfig *el;

if ((el = *pEl) == NULL) return;
freeMem(el->profile);
freeMem(el->db);
freeMem(el->classifiersRootDir);
freeMem(el->clusterJobPrefix);
freeMem(el->task);
freeMem(el->inputType);
freeMem(el->dataTableName);
freeMem(el->clinField);
freeMem(el->dataFilepath);
freeMem(el->metadataFilepath);
freeMem(el->trainingDir);
freeMem(el->validationDir);
freeMem(el->modelDir);
freeMem(el->crossValidation);
freeMem(el->classifier);
freeMem(el->outputType);
freeMem(el->parameters);
freeMem(el->dataDiscretizer);
freeMem(el->dataDiscretizerParameters);
freeMem(el->clinDiscretizer);
freeMem(el->clinDiscretizerParameters);
freeMem(el->featureSelection);
freeMem(el->featureSelectionParameters);
freeMem(el->modelPath);
freez(pEl);
}

void usrConfigFreeList(struct usrConfig **pList)
/* Free a list of dynamically allocated usrConfig's */
{
struct usrConfig *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    usrConfigFree(&el);
    }
*pList = NULL;
}

void usrConfigOutput(struct usrConfig *el, FILE *f, char sep, char lastSep) 
/* Print out usrConfig.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->profile);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->db);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->classifiersRootDir);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->clusterJobPrefix);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->task);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->inputType);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dataTableName);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->clinField);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dataFilepath);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->metadataFilepath);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->trainingDir);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->validationDir);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->modelDir);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->crossValidation);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%u", el->folds);
fputc(sep,f);
fprintf(f, "%u", el->foldMultiplier);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->classifier);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->outputType);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->parameters);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dataDiscretizer);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->dataDiscretizerParameters);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->clinDiscretizer);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->clinDiscretizerParameters);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->featureSelection);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->featureSelectionParameters);
if (sep == ',') fputc('"',f);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->modelPath);
if (sep == ',') fputc('"',f);
fputc(lastSep,f);
}

void usrConfigJsonOutput(struct usrConfig *el, FILE *f) 
/* Print out usrConfig in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"profile");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->profile);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"db");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->db);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"classifiersRootDir");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->classifiersRootDir);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"clusterJobPrefix");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->clusterJobPrefix);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"task");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->task);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"inputType");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->inputType);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"dataTableName");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->dataTableName);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"clinField");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->clinField);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"dataFilepath");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->dataFilepath);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"metadataFilepath");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->metadataFilepath);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"trainingDir");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->trainingDir);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"validationDir");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->validationDir);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"modelDir");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->modelDir);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"crossValidation");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->crossValidation);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"folds");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->folds);
fputc(',',f);
fputc('"',f);
fprintf(f,"foldMultiplier");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->foldMultiplier);
fputc(',',f);
fputc('"',f);
fprintf(f,"classifier");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->classifier);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"outputType");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->outputType);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"parameters");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->parameters);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"dataDiscretizer");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->dataDiscretizer);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"dataDiscretizerParameters");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->dataDiscretizerParameters);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"clinDiscretizer");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->clinDiscretizer);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"clinDiscretizerParameters");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->clinDiscretizerParameters);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"featureSelection");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->featureSelection);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"featureSelectionParameters");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->featureSelectionParameters);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"modelPath");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->modelPath);
fputc('"',f);
fputc('}',f);
}

void backgroundModelScoresStaticLoad(char **row, struct backgroundModelScores *ret)
/* Load a row from backgroundModelScores table into ret.  The contents of ret will
 * be replaced at the next call to this function. */
{

ret->id = sqlUnsigned(row[0]);
ret->jobs_id = sqlUnsigned(row[1]);
ret->data_table = row[2];
ret->max = sqlFloat(row[3]);
ret->mean = sqlFloat(row[4]);
ret->median = sqlFloat(row[5]);
ret->sd = sqlFloat(row[6]);
ret->min = sqlFloat(row[7]);
ret->estimatedRunTime = sqlUnsigned(row[8]);
}

struct backgroundModelScores *backgroundModelScoresLoadByQuery(struct sqlConnection *conn, char *query)
/* Load all backgroundModelScores from table that satisfy the query given.  
 * Where query is of the form 'select * from example where something=something'
 * or 'select example.* from example, anotherTable where example.something = 
 * anotherTable.something'.
 * Dispose of this with backgroundModelScoresFreeList(). */
{
struct backgroundModelScores *list = NULL, *el;
struct sqlResult *sr;
char **row;

sr = sqlGetResult(conn, query);
while ((row = sqlNextRow(sr)) != NULL)
    {
    el = backgroundModelScoresLoad(row);
    slAddHead(&list, el);
    }
slReverse(&list);
sqlFreeResult(&sr);
return list;
}

void backgroundModelScoresSaveToDb(struct sqlConnection *conn, struct backgroundModelScores *el, char *tableName, int updateSize)
/* Save backgroundModelScores as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size
 * of a string that would contain the entire query. Arrays of native types are
 * converted to comma separated strings and loaded as such, User defined types are
 * inserted as NULL. Note that strings must be escaped to allow insertion into the database.
 * For example "autosql's features include" --> "autosql\'s features include" 
 * If worried about this use backgroundModelScoresSaveToDbEscaped() */
{
struct dyString *update = newDyString(updateSize);
dyStringPrintf(update, "insert into %s values ( %u,%u,'%s',%g,%g,%g,%g,%g,%u)", 
	tableName,  el->id,  el->jobs_id,  el->data_table,  el->max,  el->mean,  el->median,  el->sd,  el->min,  el->estimatedRunTime);
sqlUpdate(conn, update->string);
freeDyString(&update);
}

void backgroundModelScoresSaveToDbEscaped(struct sqlConnection *conn, struct backgroundModelScores *el, char *tableName, int updateSize)
/* Save backgroundModelScores as a row to the table specified by tableName. 
 * As blob fields may be arbitrary size updateSize specifies the approx size.
 * of a string that would contain the entire query. Automatically 
 * escapes all simple strings (not arrays of string) but may be slower than backgroundModelScoresSaveToDb().
 * For example automatically copies and converts: 
 * "autosql's features include" --> "autosql\'s features include" 
 * before inserting into database. */ 
{
struct dyString *update = newDyString(updateSize);
char  *data_table;
data_table = sqlEscapeString(el->data_table);

dyStringPrintf(update, "insert into %s values ( %u,%u,'%s',%g,%g,%g,%g,%g,%u)", 
	tableName,  el->id,  el->jobs_id,  data_table,  el->max,  el->mean,  el->median,  el->sd,  el->min,  el->estimatedRunTime);
sqlUpdate(conn, update->string);
freeDyString(&update);
freez(&data_table);
}

struct backgroundModelScores *backgroundModelScoresLoad(char **row)
/* Load a backgroundModelScores from row fetched with select * from backgroundModelScores
 * from database.  Dispose of this with backgroundModelScoresFree(). */
{
struct backgroundModelScores *ret;

AllocVar(ret);
ret->id = sqlUnsigned(row[0]);
ret->jobs_id = sqlUnsigned(row[1]);
ret->data_table = cloneString(row[2]);
ret->max = sqlFloat(row[3]);
ret->mean = sqlFloat(row[4]);
ret->median = sqlFloat(row[5]);
ret->sd = sqlFloat(row[6]);
ret->min = sqlFloat(row[7]);
ret->estimatedRunTime = sqlUnsigned(row[8]);
return ret;
}

struct backgroundModelScores *backgroundModelScoresLoadAll(char *fileName) 
/* Load all backgroundModelScores from a whitespace-separated file.
 * Dispose of this with backgroundModelScoresFreeList(). */
{
struct backgroundModelScores *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileRow(lf, row))
    {
    el = backgroundModelScoresLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct backgroundModelScores *backgroundModelScoresLoadAllByChar(char *fileName, char chopper) 
/* Load all backgroundModelScores from a chopper separated file.
 * Dispose of this with backgroundModelScoresFreeList(). */
{
struct backgroundModelScores *list = NULL, *el;
struct lineFile *lf = lineFileOpen(fileName, TRUE);
char *row[9];

while (lineFileNextCharRow(lf, chopper, row, ArraySize(row)))
    {
    el = backgroundModelScoresLoad(row);
    slAddHead(&list, el);
    }
lineFileClose(&lf);
slReverse(&list);
return list;
}

struct backgroundModelScores *backgroundModelScoresCommaIn(char **pS, struct backgroundModelScores *ret)
/* Create a backgroundModelScores out of a comma separated string. 
 * This will fill in ret if non-null, otherwise will
 * return a new backgroundModelScores */
{
char *s = *pS;

if (ret == NULL)
    AllocVar(ret);
ret->id = sqlUnsignedComma(&s);
ret->jobs_id = sqlUnsignedComma(&s);
ret->data_table = sqlStringComma(&s);
ret->max = sqlFloatComma(&s);
ret->mean = sqlFloatComma(&s);
ret->median = sqlFloatComma(&s);
ret->sd = sqlFloatComma(&s);
ret->min = sqlFloatComma(&s);
ret->estimatedRunTime = sqlUnsignedComma(&s);
*pS = s;
return ret;
}

void backgroundModelScoresFree(struct backgroundModelScores **pEl)
/* Free a single dynamically allocated backgroundModelScores such as created
 * with backgroundModelScoresLoad(). */
{
struct backgroundModelScores *el;

if ((el = *pEl) == NULL) return;
freeMem(el->data_table);
freez(pEl);
}

void backgroundModelScoresFreeList(struct backgroundModelScores **pList)
/* Free a list of dynamically allocated backgroundModelScores's */
{
struct backgroundModelScores *el, *next;

for (el = *pList; el != NULL; el = next)
    {
    next = el->next;
    backgroundModelScoresFree(&el);
    }
*pList = NULL;
}

void backgroundModelScoresOutput(struct backgroundModelScores *el, FILE *f, char sep, char lastSep) 
/* Print out backgroundModelScores.  Separate fields with sep. Follow last field with lastSep. */
{
fprintf(f, "%u", el->id);
fputc(sep,f);
fprintf(f, "%u", el->jobs_id);
fputc(sep,f);
if (sep == ',') fputc('"',f);
fprintf(f, "%s", el->data_table);
if (sep == ',') fputc('"',f);
fputc(sep,f);
fprintf(f, "%g", el->max);
fputc(sep,f);
fprintf(f, "%g", el->mean);
fputc(sep,f);
fprintf(f, "%g", el->median);
fputc(sep,f);
fprintf(f, "%g", el->sd);
fputc(sep,f);
fprintf(f, "%g", el->min);
fputc(sep,f);
fprintf(f, "%u", el->estimatedRunTime);
fputc(lastSep,f);
}

void backgroundModelScoresJsonOutput(struct backgroundModelScores *el, FILE *f) 
/* Print out backgroundModelScores in JSON format. */
{
fputc('{',f);
fputc('"',f);
fprintf(f,"id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->id);
fputc(',',f);
fputc('"',f);
fprintf(f,"jobs_id");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->jobs_id);
fputc(',',f);
fputc('"',f);
fprintf(f,"data_table");
fputc('"',f);
fputc(':',f);
fputc('"',f);
fprintf(f, "%s", el->data_table);
fputc('"',f);
fputc(',',f);
fputc('"',f);
fprintf(f,"max");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->max);
fputc(',',f);
fputc('"',f);
fprintf(f,"mean");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->mean);
fputc(',',f);
fputc('"',f);
fprintf(f,"median");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->median);
fputc(',',f);
fputc('"',f);
fprintf(f,"sd");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->sd);
fputc(',',f);
fputc('"',f);
fprintf(f,"min");
fputc('"',f);
fputc(':',f);
fprintf(f, "%g", el->min);
fputc(',',f);
fputc('"',f);
fprintf(f,"estimatedRunTime");
fputc('"',f);
fputc(':',f);
fprintf(f, "%u", el->estimatedRunTime);
fputc('}',f);
}

/* -------------------------------- End autoSql Generated Code -------------------------------- */

